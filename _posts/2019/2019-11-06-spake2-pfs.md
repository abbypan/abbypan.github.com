---
layout: post
category: tech
title:  "PFS & PAKE"
tagline: ""
tags: [ "PAKE", "PFS", "rfc" ] 
---
{% include JB/setup %}

* TOC
{:toc}

# PFS & wPFS 

[Forward secrecy](https://en.wikipedia.org/wiki/Forward_secrecy)

[HMQV: A High-Performance Secure Diffie-Hellman Protocol](https://eprint.iacr.org/2005/176.pdf)

PFS (perfect forward secrecy) 指即使long term key泄漏，也不会影响之前的session key

wPFS (weak perfect forward secrecy) 指即使long term key泄漏，也不会影响之前passive attacker监听下的session key（但是 actively interfered attacker的session key可能受影响)

# PAKE

[pake selection](https://www.ietf.org/proceedings/104/slides/slides-104-cfrg-pake-selection-01.pdf)

Password Authenticated Key Exchange (PAKE) protocols 指的是通信双方基于共享的password安全生成session key。

balanced PAKE是指通信双方保存相同的password，augumented PAKE是指其中一方保存password的变换值。

## balanced PAKE

### Dragony,RFC7664

把pw通过指定的F函数，映射为ECC上的一个点: F(pw), 文档里记为PE

PE做为下面计算的基点

通信双方各自随机选两个整数，一个private， 一个mask

    A -> B :   private_a + mask_a,  - mask_a * PE
    B -> A :   private_b + mask_b,  - mask_b * PE

    显然，最终双方能获得 private_a*private_b*PE
    然后再派生出kck = key confirm key，mk = master key

PS: 这个RFC不好读，主要原因是，它把椭圆曲线的加法和乘法又重新用函数表述了一下

用例：[TLS-PWD, RFC8492](https://tools.ietf.org/html/rfc8492)、WIFI WPA3

### SPAKE2

[Simple Password-Based Encrypted Key Exchange Protocols](https://www.di.ens.fr/david.pointcheval/Documents/Papers/2005_rsa.pdf)
的SPAKE2是 2-message 交互，通过M，N的password幂计算协作完成类DH交换，wPFS 

[Forward Secrecy of SPAKE2](https://eprint.iacr.org/2019/351.pdf)
的PFS-SPAKE2是 3-message 交互，通过M的password幂计算协作完成类DH交换，加入了两个中间的hash确认码，PFS

通信双方已知基点P，以及另外两个点M & N，且分别选取一个随机数x
    
        A -> B : x_a * P + pw * M
        B -> A : x_b * P + pw * N
        显然，最终双方能获得 x_a*x_b*P

### SESPAKE, RFC8133

通信双方已知基点P，基于P以指定的函数派生`{ Q_1, ..., Q_N }`，且分别选取一个随机数x

    B -> A : 随机的ind、salt
    A 计算 : Q_PW = int(F(PW, salt, 2000))*Q_ind
    A -> B : u_1 = x_a*P - Q_PW
    B -> A : u_2 = x_b*P + Q_PW
    显然，最终双方能获得 x_a*x_b*P

如果B是服务端，那么可以存储`{ ind, salt, Q_PW }`，避免明文存储PW再实时计算`Q_PW` => 此时，则为augumented模式。

### J-PAKE

## augumented PAKE

### SPAKE2+

通信双方已知基点P，以及另外两个点M & N，且分别选取一个随机数x

    (w_0, w_1) = KDF(pw)   // A已知pw，B仅存储w_0、w_1*P

        A -> B : x_a * P + w_0 * M
        B -> A : x_b * P + w_0 * N
        显然，最终双方能获得 SK_0 = x_a*x_b*P, SK_1 = w_1*x_b*P
    
### AugPAKE

### SRP,RFC2945

